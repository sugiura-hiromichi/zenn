---
title: "RustとWebAssemblyによるゲーム開発 ch.1"
emoji: "🐷"
type: "tech"
topics:
  - "rust"
  - "game"
  - "webassembly"
  - "browser"
published: true
published_at: "2024-06-18 11:39"
---

とかいう、欲張りな本を見つけたので読み進めています
https://www.oreilly.co.jp/books/9784814400393/
ただ読むだけではあまり定着しないので、理解しておきたい事やつまづいた事を設問形式でまとめました

# 復習

## `src/lib.rs`内で`main_js()`がエントリポイントとなるのはなぜ

`#[wasm_bindgen(start)]`がついていると`wasm_bidgen`がjsのプログラムの起点となるようにコードを生成してくれる

# 気になったところ

## wasmはDOMにアクセス出来ないとあるが、何故だろうか 

`web-sys`クレートがブラウザのapiを、`wasm-bindgen`がjsのバインディングを提供しているようなノリでwasmからDOMを操作するapiが提供されてても良いような気がした

色々調べたが、よくわからなかった（有識者助けて）
調べた感じ、wasmは安全性とパフォーマンス、マルチプラットフォームであることに焦点を当ててるから当面domの操作のような、ブラウザ固有で高レベルな操作は視野に入れていないという感じがした
wasiとか、今後調べていきたい

sandbox：外と隔離されていてその中で起こったことが外に影響しないようになっている環境

## wasmのビルドってどうやるんだろう

`wasm-pack`がwasmのコードをビルドするとあるが、具体的にどのようにビルドしているのだろうか
ビルドした際に吐き出されるのはどのような形式のファイルなのだろう

1. そもそも`rustc`はwebassemblyをコンパイルターゲットとしてサポートしてるらしい。必要に応じて`wasm-pack`が`wasm32-unknown-unknown`を追加する
2. `wasm-bindgen`を用いてjsとの橋渡しをする


## `use hoge::prelude::*;`の`prelude`を用意する際のベストプラクティス
ってあるのかな

なるべく`prelude`に含めるものは絞る(当たり前)、`trait`など広範に使われるものに限定する etc..

逆に、調べて出てきた`prelude`のよくない点として、他人が読んだ際にどこからインポートしたものかがわかりにくいというのがあった
開発環境がlspをちゃんとセットアップしている場合はすぐにわかるだろうが、例えばgithub上で読む時などは、確かに分かりにくい

## weeアロケータ
wasmのアロケータとあるが、そもそもアロケータってなんだっけ
デフォルトのRustのアロケータよりもはるかにメモリ使用量が少ないってあるけどなんでだろう

wasmの仕様は、初めにある程度のメモリ領域を確保しておいて、必要になった時に順次領域を拡大していくようになっている。また、一度確保したメモリ領域を縮小することはできない。従って、アロケータもシンプルなもので良いらしい。また、Rustのデフォルトアロケータに対して、パフォーマンスがトレードオフらしい。